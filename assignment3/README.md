### Assignment 3 thoughts
This is in regards to the article in the reference link below:

	https://timothyteoh.medium.com/how-i-would-have-designed-the-jkjavmy-astrazeneca-appointment-database-a5502535a738 

My thought on this particular historical event are mainly divided into 3 different areas that could have been done better. The areas of focus are usually 3 different layers of an application, namely, frontend, backend and database handling. There are no right answer but depending on the resources that were given at that point of time for the technical team, the solution greatly varies. For example, budget, scaling or infrastructure options, legacy design / implementation of the application and the time needed to release.
I believe the project was mostly affected by time constraint.

The frontend did not conduct a thorough UX / UI test where all possible error handling especially on the loading of the available time slots and submissions. Common mistakes such as timeout handling and asynchronous calls cancellation was not present. First and foremost, and error pop up / toast / error message should be present due to timeout or any other errors. As we know, the current generation of users are very smart and quick with data. There are actions may consists multiple clicks that may trigger multiple asynchronous call to the server that might lock up the process, despite being multi-threaded or not. This could be handle by unsubscribing the prior call if there are no response yet and generate a new call. HTTP calls are expensive. Hence reducing unnessary loads to the backend servers or data retrieval. The frontend design tries to keep the data as 'truthful' as possible by reloading the dates availability again and again but the dates availability changes too quick which deems it a waste of time to reload the list again and again. This could be handled at the end during the submission time instead.

As for the backend, from my view, it looks like a lot of synchronous process are done in design. The backend should be handled by event queues as the real life process is that citizen / user submits their preferred dates and may not get it on the desired date. The queue could be 'ID' with a timestamp-id where the sequence of events will deemed the user queued in a sequenced to get a shot at the AZ. The queue then could be freezed for those that didn't make it for the date to be rescheduled for a different date.

I disagree with Timothy in regards to the Frontend and Backend are infinitely scalable. As the frontend were at the peak time lagged and backend have no response. Having a event queue to process the submissions at a later time would be a better option if server resource were in constraint.

On the last point, I do agree with Timothy that the culprit of most application are the design of the database. Sharding may be the easiest way to segment or isolate data access by groups of users. This could be done either with horizontal sharding or vertical sharding but with best effectiveness with combination of both method. A database table performance could deteriorate when it gets above 2GB. Hence, a horizontal sharding to reduce the table size as it grows. Thus increasing the performance with shard keys. On the vertical sharding topic, this would require both frontend team and database team to work together to design a better flow. For example, Timothy's explanation on how PPV+day partitioning. But breaking down the partition by day will make it difficult for the development team to deliver as this involves a lot of sql queries to manage or rather it will get complicated very quickly. How I would have done is that we could shard it to PPV+week giving user an range option (user experience), maybe with a week selection before performing the query. PPV centers and weeks are fixed variables where there is no need to query the database which is in the actual case. Hard code this in the frontend or maybe in a memeory db cache. After these 2 choices are selected, then only loads the week value from the partitioned database. When submitting, there are 2 options:

1. Upon submission, checks again the database again and gives instant feedback informing the user that the date is available or not. In case of unavailable, just update the frontend with the date unavailable without reloading the week. 
2. Upon submission, queues the user in an event queue to be processed later and gives a feedback that mentioned that your request has been accepted and will inform at a later time if you have got the time slot or reschedule.